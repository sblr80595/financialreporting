"""
Service to generate Excel files from financial note markdown files.
Dynamically extracts data using JSON (primary) or markdown parsing (fallback).
"""

import os
import re
import json
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
from typing import Dict, List, Tuple, Optional


class NoteExcelGenerator:
    """Generate Excel files from financial note markdown content."""

    @staticmethod
    def extract_json_data_from_markdown(md_content: str) -> Optional[Dict]:
        """
        Extract structured JSON data from markdown if available.
        This is the PRIMARY method - JSON format is generated by the AI model.
        
        Returns:
            Dict with 'note_number', 'note_title', 'period', and 'excel_data' if found
        """
        # Look for JSON block in markdown (wrapped in ```json or just {})
        json_pattern = r'```json\s*\n(\{.*?\})\s*\n```'
        match = re.search(json_pattern, md_content, re.DOTALL)
        
        if not match:
            # Try without code fence
            json_pattern = r'(\{\s*"note_number".*?"excel_data".*?\].*?\})'
            match = re.search(json_pattern, md_content, re.DOTALL)
        
        if match:
            try:
                json_str = match.group(1)
                data = json.loads(json_str)
                
                # Validate required fields
                if all(k in data for k in ['note_number', 'note_title', 'period', 'excel_data']):
                    return data
            except json.JSONDecodeError as e:
                print(f"JSON parsing failed: {e}")
                return None
        
        return None

    @staticmethod
    def extract_main_table_from_markdown(md_content: str) -> Tuple[Optional[str], Optional[str], Optional[List[Dict]]]:
        """
        FALLBACK METHOD: Extract the main note table from markdown when JSON is not available.
        
        Returns:
            Tuple of (note_number, note_title, table_data)
            - note_number: e.g., "28"
            - note_title: e.g., "EMPLOYEE BENEFITS EXPENSE"
            - table_data: List of dicts with 'particulars' and 'amount' keys
        """
        
        # Pattern to match main note header: **NOTE XX: TITLE**
        note_header_pattern = r'\*\*NOTE\s+(\d+[A-Z]?):\s*([^\*]+?)\*\*'
        
        # Find all note headers
        note_matches = list(re.finditer(note_header_pattern, md_content))
        
        if not note_matches:
            return None, None, None
        
        # Get the LAST note header (this is typically the main summary note)
        last_match = note_matches[-1]
        note_number = last_match.group(1).strip()
        note_title = last_match.group(2).strip()
        
        # Extract content after the last note header
        content_after_last_header = md_content[last_match.end():]
        
        # Find the table after this header
        # Look for markdown table: | Particulars | Amount |
        table_pattern = r'\|([^\|]+)\|([^\|]+)\|'
        table_lines = []
        
        for line in content_after_last_header.split('\n'):
            if '|' in line and not line.strip().startswith('|---'):
                table_lines.append(line)
        
        if len(table_lines) < 2:  # Need at least header + 1 data row
            return note_number, note_title, None
        
        # Parse table data
        table_data = []
        for i, line in enumerate(table_lines):
            if i == 0:  # Skip header row
                continue
            
            cells = [cell.strip() for cell in line.split('|') if cell.strip()]
            if len(cells) >= 2:
                particulars = cells[0].replace('**', '').strip()
                amount_str = cells[1].replace('**', '').replace('₹', '').replace(',', '').strip()
                
                # Try to parse amount
                try:
                    amount = float(amount_str) if amount_str and amount_str != '-' else 0
                except ValueError:
                    amount = 0
                
                table_data.append({
                    'particulars': particulars,
                    'amount': amount,
                    'is_bold': '**' in cells[0] or '**' in cells[1]  # Detect bold rows
                })
        
        return note_number, note_title, table_data

    @staticmethod
    def create_excel_from_note_data(
        note_number: str,
        note_title: str,
        table_data: List[Dict],
        period: str,
        output_path: str
    ) -> bool:
        """
        Create formatted Excel file from note data.
        
        Args:
            note_number: Note number (e.g., "28")
            note_title: Note title (e.g., "EMPLOYEE BENEFITS EXPENSE")
            table_data: List of dicts with 'particulars', 'amount', 'is_bold'
            period: Period label (e.g., "Total Jun'25")
            output_path: Path to save Excel file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            wb = Workbook()
            ws = wb.active
            ws.title = f"Note {note_number}"
            
            # Set column widths
            ws.column_dimensions['A'].width = 50
            ws.column_dimensions['B'].width = 20
            
            # Define styles
            header_font = Font(name='Calibri', size=12, bold=True)
            header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
            header_alignment = Alignment(horizontal='center', vertical='center', wrap_text=True)
            
            bold_font = Font(name='Calibri', size=11, bold=True)
            normal_font = Font(name='Calibri', size=11)
            
            center_alignment = Alignment(horizontal='center', vertical='center')
            left_alignment = Alignment(horizontal='left', vertical='center')
            right_alignment = Alignment(horizontal='right', vertical='center')
            
            thin_border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )
            
            # Row 1: Note Title
            current_row = 1
            ws.merge_cells(f'A{current_row}:B{current_row}')
            title_cell = ws[f'A{current_row}']
            title_cell.value = f"NOTE {note_number}: {note_title}"
            title_cell.font = Font(name='Calibri', size=14, bold=True)
            title_cell.alignment = center_alignment
            title_cell.fill = PatternFill(start_color="D3D3D3", end_color="D3D3D3", fill_type="solid")
            title_cell.border = thin_border
            ws[f'B{current_row}'].border = thin_border
            
            # Row 2: Period
            current_row += 1
            ws.merge_cells(f'A{current_row}:B{current_row}')
            period_cell = ws[f'A{current_row}']
            period_cell.value = f"Period: {period}"
            period_cell.font = Font(name='Calibri', size=11, italic=True)
            period_cell.alignment = center_alignment
            period_cell.border = thin_border
            ws[f'B{current_row}'].border = thin_border
            
            # Row 3: Table Headers
            current_row += 1
            ws[f'A{current_row}'] = "Particulars"
            ws[f'B{current_row}'] = "Amount (₹)"
            
            for col in ['A', 'B']:
                cell = ws[f'{col}{current_row}']
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = thin_border
                cell.font = Font(name='Calibri', size=11, bold=True, color="FFFFFF")
            
            # Data Rows
            for row_data in table_data:
                current_row += 1
                
                # Particulars column
                particulars_cell = ws[f'A{current_row}']
                particulars_cell.value = row_data['particulars']
                particulars_cell.alignment = left_alignment
                particulars_cell.border = thin_border
                
                # Amount column
                amount_cell = ws[f'B{current_row}']
                if row_data['amount'] != 0:
                    amount_cell.value = row_data['amount']
                    amount_cell.number_format = '#,##0.00'
                else:
                    amount_cell.value = '-'
                amount_cell.alignment = right_alignment
                amount_cell.border = thin_border
                
                # Apply bold formatting if needed
                if row_data.get('is_bold', False):
                    particulars_cell.font = bold_font
                    amount_cell.font = bold_font
                else:
                    particulars_cell.font = normal_font
                    amount_cell.font = normal_font
            
            # Save workbook
            wb.save(output_path)
            return True
            
        except Exception as e:
            print(f"Error creating Excel file: {str(e)}")
            return False

    @classmethod
    def generate_excel_from_markdown_file(
        cls,
        markdown_file_path: str,
        output_dir: str,
        period: str = None
    ) -> Dict:
        """
        Generate Excel file from a markdown note file.
        Tries JSON extraction first, falls back to markdown parsing.
        
        Args:
            markdown_file_path: Path to the markdown file
            output_dir: Directory to save Excel file
            period: Period label (extracted from markdown if not provided)
            
        Returns:
            Dict with success status, message, and file path
        """
        try:
            # Read markdown file
            if not os.path.exists(markdown_file_path):
                return {
                    "success": False,
                    "message": f"Markdown file not found: {markdown_file_path}"
                }
            
            with open(markdown_file_path, 'r', encoding='utf-8') as f:
                md_content = f.read()
            
            # PRIMARY METHOD: Try to extract JSON data first
            json_data = cls.extract_json_data_from_markdown(md_content)
            
            if json_data:
                # Use JSON data (preferred method)
                note_number = json_data['note_number']
                note_title = json_data['note_title']
                period = json_data.get('period', period or "Unknown Period")
                
                # Convert JSON excel_data to table_data format
                table_data = []
                for item in json_data['excel_data']:
                    table_data.append({
                        'particulars': item['particulars'],
                        'amount': float(item['amount']),
                        'is_bold': item.get('is_bold', False)
                    })
                
                print(f"✓ Using JSON structured data for Note {note_number}")
            else:
                # FALLBACK METHOD: Parse markdown table
                print("⚠ JSON not found, falling back to markdown table parsing")
                note_number, note_title, table_data = cls.extract_main_table_from_markdown(md_content)
                
                if not table_data:
                    return {
                        "success": False,
                        "message": "Could not extract table data from markdown. Please ensure the note includes structured JSON output or a properly formatted summary table."
                    }
                
                # Extract period from markdown if not provided
                if not period:
                    period_match = re.search(r'\*\*Period:\s*([^\*]+)\*\*', md_content)
                    period = period_match.group(1).strip() if period_match else "Unknown Period"
            
            # Generate output filename
            safe_title = re.sub(r'[^\w\s-]', '', note_title).strip().replace(' ', '_')
            output_filename = f"Note_{note_number}_{safe_title}.xlsx"
            output_path = os.path.join(output_dir, output_filename)
            
            # Ensure output directory exists
            os.makedirs(output_dir, exist_ok=True)
            
            # Create Excel file
            success = cls.create_excel_from_note_data(
                note_number=note_number,
                note_title=note_title,
                table_data=table_data,
                period=period,
                output_path=output_path
            )
            
            if success:
                return {
                    "success": True,
                    "message": f"Excel file generated successfully",
                    "output_file": output_path,
                    "note_number": note_number,
                    "note_title": note_title,
                    "method": "json" if json_data else "markdown"
                }
            else:
                return {
                    "success": False,
                    "message": "Failed to create Excel file"
                }
                
        except Exception as e:
            return {
                "success": False,
                "message": f"Error generating Excel: {str(e)}"
            }